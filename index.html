<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>face-moji</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --rise: 80vh; }
    body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto; background:#0f0f10; color:#eee; }
    .grid { display:grid; grid-template-columns:1fr 1fr; gap:12px; padding:90px 12px 12px; height:100vh; box-sizing:border-box; }
    .pane { position:relative; background:#000; border-radius:12px; overflow:hidden; }
    video { width:100%; height:100%; object-fit:cover; transform:scaleX(-1); }
    .label { position:absolute; top:8px; left:10px; font-size:12px; opacity:.7; }
    .emojis { position:absolute; inset:0; pointer-events:none; overflow:hidden; }
    .status { position:fixed; left:12px; bottom:12px; opacity:.8; font-size:13px; }
    .controls {
      position:fixed; top:10px; left:12px; right:12px;
      display:flex; gap:8px; align-items:center; z-index:2;
      background:#121214; border:1px solid #202026; border-radius:10px; padding:10px;
    }
    .controls input {
      flex:1; background:#0a0a0b; color:#ddd; border:1px solid #2a2a2f;
      padding:10px 12px; border-radius:8px; outline:none; font-size:14px;
    }
    .controls button {
      background:#2b6ef6; color:white; border:0; padding:10px 14px; border-radius:8px; font-weight:600;
      cursor:pointer;
    }
    .controls button.secondary { background:#2a2a2f; }
    .bubble {
      position:absolute; left:50%; bottom:8%;
      font-size:min(14vw,72px);
      filter: drop-shadow(0 6px 18px rgba(0,0,0,.6));
      will-change: transform, opacity;
      animation: rise var(--dur, 1800ms) ease-out forwards;
      transform: translateX(var(--x,0)) translateY(0);
      opacity: 0;
    }
    @keyframes rise {
      0% { transform: translateX(var(--x,0)) translateY(0) scale(1); opacity:0; }
      12% { opacity:1; }
      70% { opacity:.6; }
      100% { transform: translateX(calc(var(--x,0) + var(--drift, 0px))) translateY(calc(-1 * var(--rise))) scale(1.1); opacity:0; }
    }
    @media (max-width: 900px) { .grid { grid-template-columns:1fr; } }
  </style>
  <link rel="icon" href="data:,">
</head>
<body>
  <div class="controls">
    <strong>Room word</strong>
    <input id="roomInput" placeholder="e.g. comet-river" autocomplete="off" />
    <button id="suggestBtn" class="secondary" title="Suggest word">Suggest</button>
    <button id="startBtn">Start</button>
  </div>

  <div class="grid">
    <div class="pane">
      <div class="label">you</div>
      <video id="localVideo" autoplay playsinline muted></video>
      <div id="localLayer" class="emojis" aria-hidden="true"></div>
    </div>
    <div class="pane">
      <div class="label">peer</div>
      <video id="remoteVideo" autoplay playsinline></video>
      <div id="remoteLayer" class="emojis" aria-hidden="true"></div>
    </div>
  </div>
  <div id="status" class="status">Enter the same word on both devices. Press Start.</div>

  <script type="module">
    import { FilesetResolver, FaceLandmarker, GestureRecognizer }
      from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.mjs";
    import "https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js";

    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const localLayer = document.getElementById("localLayer");
    const remoteLayer = document.getElementById("remoteLayer");
    const statusEl = document.getElementById("status");
    const roomInput = document.getElementById("roomInput");
    const startBtn = document.getElementById("startBtn");
    const suggestBtn = document.getElementById("suggestBtn");

    remoteVideo.muted = true;

    const MAX_PARTICLES = 140;
    const MIN_GAP_MS = 140;
    const lastEmit = new Map();

    function setStatus(s) { statusEl.textContent = s; }
    function emit(layer, emoji, key = emoji) {
      const now = performance.now();
      const last = lastEmit.get(key) || 0;
      if (now - last < MIN_GAP_MS) return;
      lastEmit.set(key, now);

      const b = document.createElement("div");
      b.className = "bubble";
      b.textContent = emoji;
      b.style.setProperty("--x", (Math.random()*120-60) + "px");
      b.style.setProperty("--drift", (Math.random()*60-30) + "px");
      b.style.setProperty("--dur", (1700 + Math.random()*1200) + "ms");
      layer.appendChild(b);
      b.addEventListener("animationend", () => b.remove());
      if (layer.childElementCount > MAX_PARTICLES) {
        const excess = layer.childElementCount - MAX_PARTICLES;
        for (let i = 0; i < excess; i++) layer.firstElementChild?.remove();
      }
    }

    // Suggest simple readable room words
    const ADJ = ["solar","lunar","comet","crisp","neon","azure","gamma","swift","quiet","vivid","lively","brisk","mellow","frost","ember","nova"];
    const NOUN = ["river","meadow","orbit","oasis","forest","harbor","valley","summit","island","canyon","matrix","circuit","galaxy","vector","garden","studio"];
    function suggestWord() {
      const a = ADJ[Math.floor(Math.random()*ADJ.length)];
      const n = NOUN[Math.floor(Math.random()*NOUN.length)];
      return `${a}-${n}`;
    }

    // MediaPipe setup
    const fileset = await FilesetResolver.forVisionTasks(
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
    );
    const faceLandmarker = await FaceLandmarker.createFromOptions(fileset, {
      baseOptions: {
        modelAssetPath:
          "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task"
      },
      runningMode: "VIDEO",
      numFaces: 1
    });
    const gestureRecognizer = await GestureRecognizer.createFromOptions(fileset, {
      baseOptions: {
        modelAssetPath:
          "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task"
      },
      runningMode: "VIDEO",
      numHands: 1
    });

    function mouthState(landmarks) {
      const lmk = landmarks?.[0];
      if (!lmk) return "neutral";
      const L = lmk[61], R = lmk[291], U = lmk[13], D = lmk[14];
      if (!L || !R || !U || !D) return "neutral";
      const width = Math.hypot(L.x - R.x, L.y - R.y);
      const height = Math.hypot(U.x - D.x, U.y - D.y);
      if (width < 1e-6) return "neutral";
      const centerY = (U.y + D.y) / 2;
      const cornersY = (L.y + R.y) / 2;
      const roundness = height / width;
      const cornerDelta = (cornersY - centerY) / width;
      if (roundness >= 0.58 && Math.abs(cornerDelta) < 0.025) return "wow";
      if (roundness >= 0.36 && roundness <= 0.58 && cornerDelta <= -0.06) return "laugh";
      return "neutral";
    }

    // Camera
    const localStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
    localVideo.srcObject = localStream;
    await localVideo.play();

    // PeerJS options
    const peerOpts = {
      host: "0.peerjs.com",
      port: 443,
      secure: true,
      path: "/",
      debug: 2,
      config: {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          // replace with your own TURN for production
          { urls: "turn:openrelay.metered.ca:80" },
          { urls: "turn:openrelay.metered.ca:443" },
          { urls: "turn:openrelay.metered.ca:3478" }
        ],
        sdpSemantics: "unified-plan"
      }
    };

    let peer = null;
    let dataConn = null;
    let mediaCall = null;
    let remoteStreamArrived = false;
    let startedForRoom = null;

    function setupData(conn) {
      dataConn = conn;
      conn.on("data", msg => {
        if (msg?.type === "emoji" && msg.value) emit(remoteLayer, msg.value, "remote-" + msg.value);
      });
      conn.on("close", () => setStatus("Peer disconnected"));
      setStatus("Data channel connected");
    }

    function sendEmoji(emoji) {
      if (dataConn?.open) dataConn.send({ type:"emoji", value: emoji });
    }

    function setupMediaCallHandlers(call) {
      mediaCall = call;
      call.on("stream", remoteStream => {
        remoteStreamArrived = true;
        remoteVideo.srcObject = remoteStream;
        remoteVideo.play().catch(()=>{});
        setStatus(`Connected to ${call.peer}`);
      });
      call.on("close", () => setStatus("Call closed"));
      call.on("error", e => setStatus(`Call error: ${e?.message || e}`));
    }

    function destroyPeer() {
      try { mediaCall?.close(); } catch {}
      try { dataConn?.close(); } catch {}
      try { peer?.disconnect(); } catch {}
      try { peer?.destroy(); } catch {}
      peer = null; dataConn = null; mediaCall = null; remoteStreamArrived = false;
    }

    function startForRoom(roomWord) {
      if (!roomWord || roomWord.length < 2) { setStatus("Enter a room word."); return; }
      if (peer) destroyPeer();
      startedForRoom = roomWord;

      // Try to host on this ID; if taken, become client that connects to it.
      peer = new window.Peer(roomWord, peerOpts);
      setStatus(`Starting with room "${roomWord}"…`);

      peer.on("open", id => setStatus(`Hosting "${id}" — waiting for peer…`));
      peer.on("connection", setupData);
      peer.on("call", call => { call.answer(localStream); setupMediaCallHandlers(call); });

      // If ID is taken, switch to client mode automatically
      peer.on("error", err => {
        const msg = err?.message || "";
        if (err?.type === "unavailable-id" || /taken/i.test(msg)) {
          // Become client
          const client = new window.Peer(undefined, peerOpts);
          peer = client; // swap reference
          client.on("open", id => {
            setStatus(`Joining "${roomWord}" as ${id}`);
            const conn = client.connect(roomWord);
            conn.on("open", () => setupData(conn));
            const call = client.call(roomWord, localStream);
            setupMediaCallHandlers(call);

            // Retry once if no remote stream
            setTimeout(() => {
              if (!remoteStreamArrived && call.open) {
                setStatus("No remote stream. Retrying call…");
                call.close();
                const c2 = client.call(roomWord, localStream);
                setupMediaCallHandlers(c2);
              }
            }, 8000);
          });
          client.on("error", e2 => setStatus(`Peer error: ${e2?.message || e2}`));
        } else {
          setStatus(`Peer error: ${msg}`);
        }
      });

      peer.on("disconnected", ()=>setStatus("Signaling disconnected"));
      peer.on("close", ()=>setStatus("Peer destroyed"));
    }

    // UI wiring
    function primeInput() {
      const saved = localStorage.getItem("roomWord");
      const seed = saved || suggestWord();
      roomInput.value = seed;
    }
    primeInput();

    suggestBtn.addEventListener("click", () => {
      roomInput.value = suggestWord();
      roomInput.focus();
      roomInput.select();
    });
    startBtn.addEventListener("click", () => {
      const word = roomInput.value.trim().toLowerCase().replace(/\s+/g, "-");
      localStorage.setItem("roomWord", word);
      startForRoom(word);
    });
    roomInput.addEventListener("keydown", e => {
      if (e.key === "Enter") startBtn.click();
    });

    // Detection loop
    function loop() {
      const ts = performance.now();

      const handResult = gestureRecognizer.recognizeForVideo(localVideo, ts);
      const handGest = handResult?.gestures?.[0]?.[0];
      if (handGest?.categoryName === "Thumb_Up" && handGest.score > 0.6) {
        emit(localLayer, "👍"); sendEmoji("👍");
      }

      const faceResult = faceLandmarker.detectForVideo(localVideo, ts);
      if (faceResult?.faceLandmarks?.length) {
        const s = mouthState(faceResult.faceLandmarks);
        if (s === "laugh") { emit(localLayer, "😂"); sendEmoji("😂"); }
        else if (s === "wow") { emit(localLayer, "😮"); sendEmoji("😮"); }
      }

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    if (location.protocol !== "https:" && location.hostname !== "localhost") {
      setStatus("Tip: Use HTTPS or localhost for camera.");
    }
  </script>
</body>
</html>
